## 一、概述

​		JAVA GC（Garbage Collection，垃圾回收）机制是区别 C++ 的一个重要特征，C++ 需要开发者自己实现垃圾回收的逻辑，而 JAVA 开发者则只需要专注于业务开发，因为垃圾回收这件繁琐的事情 JVM 已经为我们代劳了，从这一点上来说，JAVA 还是要做的比较完善一些。但这并不意味着我们不用去理解 GC 机制的原理，因为如果不了解其原理，可能会引发内存泄漏、频繁 GC 导致应用卡顿,甚至出现 OOM 等问题，因此我们需要深入理解其原理，才能编写出高性能的应用程序，解决性能瓶颈。

## 二、GC 机制

​		在 JVM 的五个内存区域中，有 3 个是不需要进行垃圾回收的：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放。所以，只有方法区和堆区需要进行垃圾回收，回收的对象就是那些不存在任何引用的对象。

### 1. 垃圾标记算法

#### 	1.1 引用计数算法

​		a. 通过判断对象的引用数量来决定对象是否可以被回收。

​		b. 每个对象实例都有一个引用计数器，被引用则 +1，完成引用则 -1。

​		c. 引用计数为 0 的对象可以被回收。

​		**优点：**执行效率高，程序执行受影响较小（只需要过滤引用计数为0的对象）。

​		**缺点：**无法检测出循环引用的情况，导致内存泄漏（子对象引用父对象，父对象引用子对象）

#### 	1.2 可达性分析算法

​		a. 通过判断对象的引用链是否可达来决定对象是否可以被回收。

​		b. 通过 GC Root 作为起始点，开始向下搜索，搜索所走过的路径被称为引用链。

​		**GC Root：**

​			a. 虚拟机栈中引用的对象（栈帧中的**本地变量表**）

​			b. 方法区中的**常量引用的对象**

​			c. 方法区中的**类静态属性引用的对象**

​			d. 本地方法栈中的JNI（**Native方法**）的引用对象

​			e. 活跃线程的引用对象

### 2. 垃圾回收算法

#### 	2.1 标记-清除算法

​		**标记：**从根 Root 进行扫描，对存活的对象进行标记

​		**清除：**对堆内存进行线性遍历，回收不可达对象内存

​		**缺点：**内存碎片化

#### 	2.2 复制算法

​		分为**对象面**和**空闲面**

​		对象在对象面上创建，存活的对象被从对象面复制到空闲面，将对象面所有对象内存清除

​		**优点：**解决了内存碎片化，顺序分配内存，适用于对象存活率低的场景

​		**缺点：**浪费 50% 的内存空间

#### 	2.3 标记-整理算法

​		**标记：**从根 Root 进行扫描，对存活的对象进行标记

​		**清除：**移动所有存活的对象，且按照内存地址次序依次排序，然后将末端内存地址以后的内存全部回收。

​		**优点：**解决了内存碎片化，不用设置两块内存互换，适用于对象存活率高的场景

#### 	2.4 分代收集算法

​		按照对象生命周期的不同划分区域采用不同的垃圾回收算法

​		a. **新生代：**MinorGC，采用**复制算法**，新生对象在 Eden 区

​			当**第一次 **Eden 被占满后，第一次触发 MinorGC，此时，将 Eden中的存活对象复制到 Sur0，并标记对象年龄为 1，清空 Eden。

​			当**第二次** Eden 被占满后，第二次触发 MinorGC，此时，将 Eden 中的存活对象和 Sur0 中的存活对象复制到 Sur1，并标记原 Sur0 对象年龄为 2，原 Eden对象为 1，清空 Eden 和 Sur0。

​			当**第三次** Eden 被占满后，第三次触发 MinorGC，此时，将 Eden 中的存活对象和 Sur1 中的存活对象复制到 Sur0，并标记对象年龄 +1，清空 Eden 和 Sur1。

 			默认对象年龄超过 15 岁时会复制到老年代（-XX:MaxTenuringThreshold=15）。

​		b. **老年代：**FullGC 和 MajorGC，采用**标记-清除**或**标记-整理**

​		c. **触发 FullGC 的条件**

​			老年代空间不足

​			调用 System.gc()

​			Minor GC 晋升到老年代的平均大小大于老年代的剩余空间

​			CMS GC 时出现 promotion failed（MinorGC 时，Sur 中存放不下，只能存放于老年代，而老年代也放不下），concurrent mode failure（执行CMS GC时，同时有对象需要放入老年代，而老年代没有足够空间）

​			使用 RMI 来进行 RPC 或管理 JDK 应用，每小时执行一次 Full GC

### 3. 垃圾收集器

**Stop-the-World：**

​		JVM 由于要执行 GC 而停止了应用程序的执行

​		任何一种 GC 算法中都会发生

**Safepoint：**

​		当线程运行到这些特定的位置时，线程的一些状态可以被确定，**从而确定 GC Root 的信息**，使 JVM 可以安全的进行一些操作，比如开始 GC。

​		产生 Safepoint 的地方：方法调用，循环跳转，异常跳转

​		安全点数量需要适中

#### 	3.1 年轻代：

##### 			a. Serial 收集器

​		-XX:UseSerialGC，单线程、复制算法

​		单线程收集，进行垃圾收集时，必须暂停所有工作线程

##### 	b. ParNew 收集器

​		-XX:UseParNewGC，多线程、复制算法			

​		JVM Client 模式下的默认年轻代收集器

​		多线程收集器，其余的行为、特点和 Serail 收集器一样

##### 			c. Parallel Scavenge 收集器（默认）

​		-XX:UseParallerGC，多线程、复制算法、高效			

​		JVM Server 模式下的**默认年轻代收集器**

​		比起前两种关注用户线程的停顿时间，更关注系统的吞吐量（吞吐量=运行代码时间/(运行代码时间+垃圾收集时间)）

#### 	3.2 老年代：

##### 			a. Serial Old 收集器

​		-XX:UseSerialOldGC，单线程、**标记-整理**算法

​		JVM Client 模式下的默认老年代收集器

​		单线程收集，进行垃圾收集时，必须暂停所有工作线程

##### 			b. Parallel Old 收集器（默认）

​		-XX:UseParallelOldGC，多线程、**标记-整理**算法	

​		多线程，吞吐量优先

##### 			c. CMS 收集器

​		在收集过程中可以与用户线程并发操作。它可以与Serial收集器和 Parallel New 收集器搭配使用。CMS牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。

​		-XX:+UseConcMarkSweepGC，多线程、**标记-清除**算法	

​		**初始标记**：标记 GC ROOT 能直接关联到的对象，速度很快。stop-the-world

​		**并发标记**：判断对象是否与 GC ROOT 有引用链。并发追溯标记，程序不会停顿

​		**并发预清理**：查找执行并发标记阶段从年轻代晋升到老年代的对象

​		**可被终止的预清理**：

​		**重新标记**：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，扫描CMS堆中的剩余对象。stop-the-world

​		**并发清理**：清理垃圾对象，程序不会停顿

​		**并发重置**：重置 CMS 收集器的数据结构

​	缺点：

​			**因为并发收集，占用了一部分 CPU 资源，导致应用程序变慢**。默认启动垃圾回收线程数量为：(CPU 数量 + 3) / 4，至少占 25% 的资源。

​			**CMS 无法处理浮动垃圾**。由于 CMS 并发清理阶段用户线程仍在运行，伴随着程序运行就会产生垃圾，这些垃圾无法在当次的回收过程中回收，要等到下一次回收（即浮动垃圾）。

​			**基于标记清除算法会产生大量内存碎片**。添加配置优化：-XX:CMSFullGCsBeforeCompaction=10。意思是说在上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩。默认是0，也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。 如果把CMSFullGCsBeforeCompaction配置为10，就会让上面说的第一个条件变成每隔10次真正的full GC才做一次压缩。

​			**remark 阶段优化**：一般 CMS 的 GC 耗时 80% 都在 remark 阶段，添加配置 `-XX:+CMSScavengeBeforeRemark`，在执行 remark 操作之前先做一次 Young GC，目的在于减少年轻代对老年代的无效引用，降低 remark 时的开销

![](../img/jvm-cms.jpg)

##### 			d. G1 收集器（默认）

​		-XX:+UseG1GC，**复制+标记-整理**算法，JDK 1.9 默认	

​		将整个 Java 堆内存划分为**多个大小相同**的区域 region，可以有计划的避免在全区域进行垃圾收集。

​		回收方式：跟踪每一个 region 里的垃圾堆积的价值大小（回收所得的空间大小以及所需耗费时间的经验值），维护一个优先列表，每次根据允许的回收时间，优先回收价值最大的 region。

​		region 之间的引用：新生代跟老年代之间的引用根据 remebered set 来避免全盘扫描，每一个 region 都维护一个 remebered set 

​		初始标记（STW）：

​		并发标记：

​		最终标记（STW）：

​		筛选回收：

​	特点：

​		并行和并发：利用多核环境减少停顿时间

​		分代收集：不需要配合其他收集器

​		空间整合：整体上看属于标记整理算法，局部（Region 之间）数据复制算法。运作期间不会产生空间碎片

​		可预测的停顿：

​		**说明：**

​			将整个 JAVA 堆内存划分为多个大小相等的 Region

​			年轻代和老年代不再物理隔离

##### 			e. Epsilon GC 收集器

​				。。。

##### 			f. ZGC 收集器

​			基于**动态Region**内存布局

​			不设年龄分代

​			使用了**读屏障**、**染色指针**和**内存多重映射**等技术来实现**可并发的标记-整理算法**的收集器

​			回收TB级内存（最大4T），停顿时间不超过10ms。

​			**动态Region：**

​				分多个大、中、小三类容量

​				小型Region：每个固定容量为2MB，用于存放小于256KB的小对象

​				中型Region：每个固定容量为32MB，用于存>=256KB，<=4MB的对象

​				大型Region：每个容量不固定，可动态变化，必须是2MB的整数倍，用于存放4MB以上的大对象。

​										每个大型Region中只会存放一个大对象。

​										大型Region在ZGC的实现中是不会被重新分配的，因为复制一个大对象的代价非常高昂。

​			**染色指针技术：**

​					把标记直接记录在对象头上（如Serial收集器）

​					把标记记录在与对象相互独立的数据结构上（如G1收集器）

​					直接把标记记录在引用对象的指针上（如ZGC收集器）

​			**三色标记：**

​					在并发的可达性分析算法中使用三色标记来标记对象是否被收集器访问过。

​					**白色：**表示对象尚未被垃圾收集器访问过。在可达性分析算法的开始阶段，所有的对象都是白色的，在分析结束阶段，仍然是白色的则表示不可达。

​					**黑色：**表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已被扫描过。且表示该对象是安全存活的。

​								如果有其他对象引用指向了黑色对象，无需重新扫描。

​					**灰色：**表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

​					**异常：**

​						 **对象消失理论：**

​							a. 赋值器插入一条或多条从黑色对象到白色对象的新引用

​							b. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

​					**解决：**

​						a. 增量更新，将新插入的扫描记录下来，在并发扫描结束后，以记录中的黑色对象为根重新扫描

​						b. 原始快照，将要删除的引用记录下来，在并发扫描结束后，以记录中的灰色对象为根重新扫描

​			**内存多重映射：**

​					将多个不同的虚拟机内存地址映射到同一个物理内存地址上，意味着ZGC在虚拟内存中看到地址空间要比实际的堆内存容量更大

​			**读屏障：**

##### 	g. Shenandoah GC 收集器

​			。。。

### 

#### 3.3 OopMap

​		OopMap 记录了栈上本地变量到堆上对象的引用关系。

​		其作用是：垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。但问题是，栈上的本地变量表里面只有一部分数据是 Reference 类型的（它们是我们所需要的），那些非 Reference 类型的数据对我们而言毫无用处，但我们还是不得不对整个栈全部扫描一遍，这是对时间和资源的一种浪费。

​		一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 

​		gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。

#### 3.4 卡表

​		现代JVM，堆空间通常被划分为新生代和老年代。由于新生代的垃圾收集通常很频繁，如果老年代对象引用了新生代的对象，那么，需要跟踪从老年代到新生代的所有引用，从而避免每次YGC时扫描整个老年代，减少开销。

​		对于HotSpot JVM，使用了卡标记（Card Marking）技术来解决老年代到新生代的引用问题。具体是，使用卡表（Card Table）和写屏障（Write Barrier）来进行标记并加快对GC Roots的扫描。

> 基于卡表（Card Table）的设计，通常将堆空间划分为一系列2次幂大小的卡页（Card Page）。
>
> 卡表（Card Table），用于标记卡页的状态，每个卡表项对应一个卡页。
>
> HotSpot JVM的卡页（Card Page）大小为 512 字节，卡表（Card Table）被实现为一个简单的字节数组，即卡表的每个标记项为 1 个字节。
>
> 当对一个对象引用进行写操作时（对象引用改变），写屏障逻辑将会标记对象所在的卡页为 dirty。

#### 3.5 RememberedSet

​		使用 rememberedSet 来避免全堆扫描

​		RememberedSet 用于处理这类问题：比如说，新生代 gc （它发生得非常频繁）。一般来说， gc 过程是这样的：首先枚举根节点。根节点有可能在新生代中，也有可能在老年代中。这里由于我们只想收集新生代（换句话说，不想收集老年代），所以没有必要对位于老年代的 GC Roots 做全面的可达性分析。但问题是，确实可能存在位于老年代的某个 GC Root，它引用了新生代的某个对象，这个对象你是不能清除的。那怎么办呢？

​		仍然是拿空间换时间的办法。事实上，对于位于不同年代对象之间的引用关系，虚拟机会在程序运行过程中给记录下来。对应上面所举的例子，“老年代对象引用新生代对象”这种关系，会在引用关系发生时，在新生代边上专门开辟一块空间记录下来，这就是 RememberedSet 。所以“新生代的 GC Roots ” + “RememberedSet 存储的内容”，才是新生代收集时真正的 GC Roots 。然后就可以以此为据，在新生代上做可达性分析，进行垃圾回收。

​		我们知道， G1 收集器使用的是化整为零的思想，把一块大的内存划分成很多个域（ Region ）。但问题是，难免有一个 Region 中的对象引用另一个 Region 中对象的情况。为了达到可以以 Region 为单位进行垃圾回收的目的， G1 收集器也使用了 RememberedSet 这种技术，在各个 Region 上记录自家的对象被外面对象引用的情况。![](../img/jvm-rememberedset.png)