## 1. 简述

​        虚拟机把描述类的数据从 class 文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。

​		类的加载是指将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。

​		什么时候触发类的加载：

> (1) 使用 new 关键字实例化对象
> (2) 读取或设置一个类的静态变量的时候
> (3) 调用类的静态方法是时候
> (4) 对类进行反射调用是时候
> (5) 初始化子类时，父类会先被初始化
> (6) 对类使用静态代理的时候需要先被初始化

## 		2. 类的加载过程

### 2.1 类生命周期的七个阶段

​		类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7 个阶段。其中验证、准备、解析 3 个部分统称为连接（Linking）。

![](../img/jvm/类的加载过程.png)

![](D:/Book/MyNotes/my-notes/img/jvm/类的加载过程2.png)

​		加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。（注意，这里说的是按部就班地“开始”，而不是按部就班地“进行”或“完成”，强调这点是因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段）。

​		什么时候需要开始类第一个阶段“加载”，虚拟机规范没有强制约束，这点交给虚拟机的具体实现来自由把控。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有6种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

> - 遇到 new、getstatic、putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化生成这 4 条指令的最常见的 Java 代码场景是：使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
> - 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
> - 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
> - 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。
> - 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
> - 当一个接口中定义了被 default 关键字修饰的方法（JDK1.8 新加入的默认方法）时，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

#### 2.1.1 加载

​	**加载阶段虚拟机需要完成以下 3 件事情：**

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

##### 	1. 类的加载机制

> **父类委托**：先让父类加载器加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。
>
> **全盘负责**：当一个类加载器负责加载某个 Class 时，该 Class 所依赖和引用的其他 Class 也将由该类加载器负责载入，除非显式使用另一个类加载器来载入。
>
> **缓存机制**：保证所有加载过的 Class 都会被缓存，当程序中需要某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区中不存在，系统才会读取对应的二进制数据，并将其转化为 Class 对象，存入缓存区。这就是为什么修改 Class 后，必须重启 JVM，程序的修改才会生效。

##### 	2. 双亲委派模型

> 防止内存中出现多份同样的字节码
>
> 保证 Java 程序安全稳定运行，可以防止核心 API 被篡改

#### 2.1.2 验证

​		确保加载的类的正确性。

​		确保 Class 文件中字节流包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全。

> - **文件格式验证**：验证字节流是否符合 Class 文件格式的规范，保证输入的字节流能正确的解析并存储于方法区内。
>
>   这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进人 Java 虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构（内存）上进行的，不会再直接读取、操作字节流了。
>
> - **元数据验证**：基于方法区的存储结构进行；对类的元数据信息进行语义校验，保证不存在不符合 Java 语义规范的元数据信息。
>
>   1）这个类是否有父类(除了 java.lang.Object 之外，所有的类都应当有父类)
>   2）这个类的父类是否继承了不允许被继承的类(被 final 修饰的类)。
>   3）如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
>   4）类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的 final 字段，或者出现不符合规则的方法重载，例如方法参数都-致，但返回值类型却不同等)
>   5）…
>
> - **字节码验证**：基于方法区的存储结构进行；进行数据流和控制流分析，对类的方法体（Class 文件中的 Code 属性）进行校验，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
>
>   1）保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个 int 类型的数据，使用时却按 long 类型来加载入本地变量表中”这样的情况。
>   2）保证任何跳转指令都不会跳转到方法体以外的字节码指令上
>   3）保证方法体中的类型转换总是有效的，例如可以把-个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的
>   4）…
>
> - **符号引用验证**：基于方法区的存储结构进行；发生在虚拟机将符号引用转化为直接引用的时候，主要对类自身以外的信息(常量池中的各种符号引用)进行匹配性校验。
>
>   1）符号引用中通过字符串描述的全限定名是否能找到对应的类。
>   2）在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
>   3）符号引用中的类、字段、方法的可访问性（private、protected、public）
>   4）是否可被当前类访问
>   5）…

#### 2.1.3 准备

​		正式为类的静态变量分配内存，并将其初始化为**默认值**，在方法区中分配。

> 1. 这时候进行内存分配的仅包括**类变量(static)**，分配在方法区中，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
>
> 2. 如果类字段同时被 final 和 static 修饰，那么在准备阶段就会被初始化为所指定的值。

**注：**

​		对于**基本数据类型**来说，对于**类变量(static)和全局变量**，如果不显示的赋值而直接引用，则系统会为其赋予默认的 0 值；对于局部变量来说，则必须显式的赋值。

​		对于**同时被 static 和 final 修饰的常量**，必须声明的时候为其显式的赋值。

​		对于**只被 final 修饰**的常量，既可以声明时显式的为其赋值，也可以初始化时显式的为其赋值。必须使用前为其显式的赋值。

​		对于**引用数据类型**，系统会为其赋予默认 0 值。

#### 2.1.4 解析

​		虚拟机将常量池中的符号引用转化为直接引用的过程。符号引用是一种定义，可以是任何字面上的含义，而直接引用就是直接指向目标的指针、相对偏移量。

​		解析阶段可能开始于初始化之前（类被加载器加载时），也可能在初始化之后（符号引用将要被使用前）。

​		对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可能会**对第一次解析的结构进行缓存(在运行时常量池中记录直接引用，并把常量标识为已解析状态)**，从而避免解析动作重复进行。

​		解析动作主要针对类或接口，字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。

> 类或接口的解析：
>
> 字段解析：
>
> 类方法解析：
>
> 接口方法解析：

​		**解析**阶段在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 的运行时绑定。

> Java 中的绑定：绑定指的是把一个**方法的调用**与方法**所属的类**(方法主体)关联起来。就是在执行方法调用的时候，jvm 知道调用了哪个类的哪个方法。
>
> 静态绑定：即前期绑定。在程序执行前方法以及被绑定，此时由编译器或其他连接程序实现。针对 Java，可以理解为程序编译期的绑定。
>
> ​					Java 中的方法只有 final、static、private 和构造方法是前期绑定的。 
>
> 动态绑定：即晚期绑定。在运行时根据具体对象的类型进行绑定，运行时绑定是通过一个叫做方发表的结构来处理的。
>
> ​					针对 Java，几乎所有的方法都是后期绑定

#### 2.1.5 初始化

​		是执行类构造器 \<clinit\>() 方法的过程，主要是对一个 class 中的 static{} 语句进行操作（对应字节码就是 clinit 方法）。

##### 1. clinit() 方法的执行规则

> 1. \<clinit\>() 方法是由编译器自动收集类中所有的**类变量的赋值动作和静态语句块**中的语句合并产生的，编译器收集的顺序是由语句在源文件中的顺序所决定的。**静态语句块中只能访问到定义在静态语句块之前的变量****，在前面的静态语句中可以赋值，但是不能访问**。
>
> 2. \<clinit\>() 方法与实例构造器 \<init\>() 方法不同，他不需要显示的调用父类构造器。虚拟机会保证在子类的 \<clinit\>() 方法执行前，父类的 \<clinit\>() 方法已经执完完毕。因此，在虚拟机中，第一个被执行的 \<clinit\>() 方法的类肯定是 java.lang.Object。
>
> 3. \<clinit\>() 方法对应类或者接口来说不是必须的。如果类中没有静态语句块，也没有类变量的赋值操作，那么编译器可以不为这个类生成 \<clinit\>() 方法。
>
> 4. 接口中不能使用静态语句块，但仍然有类变量(final static) 初始化的赋值操作，因此，接口和类一样会生成 \<clinit\>() 方法。不同的是，执行接口的 <clinit\>() 方法不需要先执行父接口的 \<clinit\>() 方法，只有在父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的 \<clinit\>() 方法。
>
> 5. 虚拟机会保证一个类的 \<clinit\>() 方法在多线程环境中被正确的加锁和同步。如果在一个类的 \<clinit\>() 方法中有耗时很长的操作，那就有可能造成多线程阻塞。

##### 2. 类进行初始化情况

主动引用

> 虚拟机规范严格规定了有且只有六种情况下必须对类立即进行初始化：
>
> 1. 遇到 **new、getstatic、putstatic、invokestatic** 这四条字节码指令时，如果类还没有初始化则需要先触发其初始化：
>    - 即使用 new 关键字实例化对象时
>    - 读取或设置一个类的静态字段(static) 时(同时被 static 和 final 修饰的，已在编译期把结果放入常量池的静态字段除外)
>    - 调用一个类的静态方法的时候。
>
> 2. 使用 java.lang.refect 包的方法对类进行反射调用时
>
> 3. 当初始化一个类时，如果其父类还没有初始化，则需要先触发其父类的初始化
>
> 4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类
> 5. 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
> 6. 当一个接口中定义了被 default 关键字修饰的方法（JDK1.8 新加入的默认方法）时，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

被动引用

> 1、通过子类引用父类中的静态字段，不会初始化子类，只会初始化父类。对应静态字段，只有直接定义这个字段的类才会被初始化。
>
> 2、常量在编译阶段会存入调用它的类的常量池中。本质上，没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化。
>
> 3、通过数组定义来引用类，不会触发类的初始化

##### 3. 类的实例化顺序

（1）类中的 static 代码在类加载时就执行，且只执行一次。(先静态)

（2）如果 A 类继承自 B 类，则 A 实例化之前要先加载 B，执行 A 的构造函数时要先执行 B 的构造函数，所以要先实例化 B。(先父后子)

（3）一个类实例化之前要先实例化类的成员变量(非静态)，再执行类的构造函数。(先成员后构造)

> **Java 类实例化详细顺序**：
>
> 1、父类【静态成员】和【静态代码块】，按在代码中出现的先后顺序执行
>
> 2、子类【静态成员】和【静态代码块】，按在代码中出现的先后顺序执行
>
> 3、父类的【普通成员变量】和【普通代码块】，按在代码中出现的先后顺序执行
>
> 4、执行父类的构造方法
>
> 5、子类的【普通成员变量】和【普通代码块】，按在代码中出现的先后顺序执行
>
> 6、子类的构造方法

## 3. 类加载器

​		虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。

### 3.1 JVM中类加载器的分类

#### 3.1.1 JDK 提供的三层类加载器

- **启动类加载器（Bootstrap ClassLoader）**
  这是加载器中的扛把子，任何类的加载行为，都要经它过问。它的作用是加载核心类库，也就是 rt.jar、resources.jar、charsets.jar 等。当然这些 jar 包的路径是可以指定的，-Xbootclasspath 参数可以完成指定操作。
  这个加载器是 C++ 编写的，是虚拟机自身的一部分，随着 JVM 启动。
- **扩展类加载器（Extension ClassLoader）**
  扩展类加载器，主要用于加载 lib/ext 目录下的 jar 包和 .class 文件。同样的，通过系统变量 java.ext.dirs 可以指定这个目录。
  这个加载器是个 Java 类，继承自 URLClassLoader。
- **应用程序类加载器（Application ClassLoader）**
  这是我们写的 Java 类的默认加载器，有时候也叫作 System ClassLoader。一般用来加载 classpath 下的其他所有 jar 包和 .class 文件，我们写的代码，会首先尝试使用这个类加载器进行加载。

> 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。这里所指的“相等”，包括代表类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。

### 3.2 双亲委派模型

​		双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。

​		双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

​		使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。

![](../img/jvm/class_loader.jpg)

### 3.3 自定义类加载器 -- 可以打破双亲委派模型

#### 3.3.1 [Tomcat 类加载机制](https://www.cnblogs.com/aspirant/p/8991830.html)

​		tomcat 通过 war 包进行应用的发布，它其实是违反了双亲委派机制原则的。**对于一些未加载的非基础类(Object, String等)，各个 web 应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给 commonClassLoader 走双亲委托。**

​		双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader 加载自己的目录下的 class 文件，不会传递给父类加载器。

> 1. Common 类加载器，负责加载 Tomcat 和 Web 应用都复用的类
> 2. Catalina 类加载器，负责加载 Tomcat 专用的类，而这些被加载的类在 Web 应用中将不可见
> 3. Shared 类加载器，负责加载 Tomcat 下所有的 Web 应用程序都复用的类，而这些被加载的类在 Tomcat 中将不可见
> 4. WebApp 类加载器，负责加载具体的某个 Web 应用程序所使用到的类，而这些被加载的类在 Tomcat 和其他的 Web 应用程序都将不可见
> 5. Jsp 类加载器，每个 jsp 页面一个类加载器，不同的 jsp 页面有不同的类加载器，方便实现 jsp 页面的热插拔

![](../img/jvm/tomcat_class_loader.jpg)

- CommonClassLoader 能加载的类都可以被 CatalinaClassLoader 和 SharedClassLoader 使用，从而实现了公有类库的共用，而 CatalinaClassLoader 和 SharedClassLoader 自己能加载的类则与对方相互隔离。
- WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。
- 而 JasperLoader 的加载范围仅仅是这个JSP文件所编译出来的那一个 .Class 文件，它出现的目的就是为了被丢弃：当 Web 容器检测到 JSP 文件被修改时，会替换掉目前的 JasperLoader 的实例，并通过再建立一个新的Jsp 类加载器来实现JSP文件的 HotSwap 功能

## 4. 总结

**类加载过程中主要是将 Class 文件(类的二进制字节流) 加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才直接开始。**

虚拟机把描述类的数据从 Class 文件(类的二进制字节流) 加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型 。

















