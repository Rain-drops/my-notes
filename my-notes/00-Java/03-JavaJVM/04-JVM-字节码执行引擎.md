## 一、简述

​		JVM 的字节码执行引擎，负责具体的代码调用及执行过程。在不同的虚拟机实现里面，执行引擎在执行 Java 代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种方式。目前而言，所有的 Java 虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

​		每个字节码指令都由一个 1 字节的操作码和附加的操作数组成。

## 二、运行时栈帧结构

​		每一个线程都有一个栈，也就是虚拟机栈，栈中的基本元素我们称之为栈帧。**栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构**，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量、操作数栈、动态链接和方法返回地址等信息。**每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。**

​		在编译程序代码时，栈帧中需要多大的局部变量表和多深的操作数栈都已经完全确定，并写入到方法表的 Code 属性中。在活动的线程中，位于当前栈顶的栈帧才是有效的，称之为当前帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令只针对当前栈帧进行操作。需要注意的是一个栈中能容纳的栈帧是受限的，过深的方法调用可能会导致 StackOverFlowError，当然，我们可以人为的设置栈的大小。

![](../img/jvm/虚拟机栈.jpeg)

### 2.1 局部变量表

​		局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在 Java 程序编译为 Class 文件时，就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需要分配的局部变量表的最大容量。由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。如果是实例方法，那局部变量表第0位索引的Slot存储的是方法所属对象实例的引用，因此在方法内可以通过关键字this来访问到这个隐含的参数。其余的参数按照参数表顺序排列，参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。

　　类变量有两次赋初始值的过程，一次是准备阶段，赋予系统初始值，int = 0，boolean = false；另一次是初始化阶段，赋予程序员定义的初始值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但是局部变量不一样，如果一个局部变量定义了但没有赋初始值是不能使用的，字节码校验的时候也会被虚拟机发现而导致类加载失败！

### 2.2 操作数栈

​		操作数栈（Operand Stack）是一个后进先出栈，由字节码指令往栈中存数据和取数据，栈中的任何一个元素都是可以任意的Java数据类型。和局部变量类似，操作数栈的最大深度也在编译的时候写入到 Code 属性的 max_stacks 数据项中。

​		当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数中写入和提取内容，也就是出栈/入栈操作。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。另外我们说 Java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。

### 2.3 动态链接

​		每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有该引用是为了支持方法调用过程中的动态连接。

​		Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态链接。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态链接。

　　当前线程的栈帧通过获取方法的直接引用，指向着常量池对应方法的字节码，就可以利用常量池、操作数栈执行方法。

### 2.4 方法返回地址

​		存放调用该方法的 pc 计数器的值。

​		当一个方法开始执行后，只有两种方式可以退出这个方法。

​		1. 第一种：执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；

​		2. 第二种：在方法的执行过程中遇到了异常（Exception），并且议程没有在方法体中处理，简称异常完成出口；

​		无论何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的 PC 计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。

​		方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上次方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。

## 三、方法调用

​		方法调用并不等于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作，但 Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于上面说的直接引用）。这个特性给 Java 带来了更强大的动态扩展能力，但也使得 Java 方法调用过程变得相对复杂起来，需要在类加载期间，设置到运行期间再能确定目标方法的直接引用。

### 3.1 解析

​		在 Class 文件中，所有方法调用中的目标方法都是常量池中的符号引用，在类加载的解析阶段，会将一部分符号引用转为直接引用，这种解析能成立的前提是方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，这类方法的调用称为解析调用。此类方法主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可访问，因此决定了他们都不可能通过继承或者别的方式重写该方法，符合这两类的方法主要有以下几种：静态方法、私有方法、实例构造器、父类方法。

> 虚拟机中提供了以下几条方法调用指令：
>
> 1. invokestatic：调用静态方法，解析阶段确定唯一方法版本
> 2. invokespecial：调用 \<init\> 方法、私有及父类方法，解析阶段确定唯一方法版本
> 3. invokevirtual：调用所有虚方法
> 4. invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象；
> 5. invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

​		前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而 invokedynamic 指令则支持由用户确定方法版本。其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（final 修饰的除外）称为虚方法。**只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法 4 类，它们在加载的时候就会把符号引用解析为直接引用。**

​		Java 中的非虚方法除了使用 invokestatic、invokespecial 调用的方法之外还有一种，就是被 final 修饰的方法。虽然 final 方法是使用 invokevirtual 指令来调用的，但是由于它无法被覆盖，没有其它版本，所以也无需对方法接受者进行多态选择，又或者说多态选择的结果肯定是唯一的。在 Java 语言规范中明确说明了 **final 方法是一种非虚方法。**

​		**解析调用一定是个静态过程，在编译期间就能完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。**而分派（Dispatch）调用则可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。这两类分派方式的两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派 4 种分派组合情况，下面我们再看看虚拟机中的方法分派是如何进行的。

### 3.2 分派

​		分派调用更多的体现在多态上。**如「重载」和「重写」在 Java 虚拟机中是如何实现的？虚拟机是如何确定正确目标方法的？**

​		Java 语言是一种静态多分派，动态单分派语言。

#### 3.2.1 静态分派与动态分派

**1. 静态分派（方法重载关联）**　　

​		变量本身的静态类型不会被改变，静态类型在编译期可知，而实际类型变化的结果在运行期才可确定。静态方法会在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的。

​		所有依赖静态类型来定位方法执行版本的分派称为静态分派，典型应用是方法重载 。**静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。**

```java
/**
 * 方法静态分派演示
 */
public class StaticDispatch {
    private static abstract class Human { }
    private static class Man extends Human { }
    private static class Woman extends Human { }
    private void sayHello(Human guy) {
        System.out.println("Hello, guy!");
    }
    private void sayHello(Man man) {
        System.out.println("Hello, man!");
    }
    private void sayHello(Woman woman) {
        System.out.println("Hello, woman!");
    }
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch dispatch = new StaticDispatch();
        dispatch.sayHello(man);    // Hello, guy!
        dispatch.sayHello(woman);  // Hello, guy!
    }
}
```

​		上面这段代码中的**「Human」称为变量的静态类型**（Static Type），后面的**「Man」称为变量为实际类型**（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅发生在使用时，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。

**2. 动态分派（方法的重写关联）**

​		在运行期间根据实际类型来确定方法执行版本的分派成为动态分派，发生在程序运行期间，典型的应用是方法的重写 。

```java
/**
 * 方法动态分派演示
 */
public class DynamicDispatch {
    static abstract class Human {
        abstract void sayHello();
    }
    static class Man extends Human {
        @Override
        void sayHello() {
            System.out.println("Man say hello!");
        }
    }
    static class Woman extends Human {
        @Override
        void sayHello() {
            System.out.println("Woman say hello!");
        }
    }
    public static void main(String[] args){
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();    // Man say hello!
        woman.sayHello();  // Woman say hello!
        man = new Woman();
        man.sayHello();    // Woman say hello!
    }
}
```

​		对于上面的代码，虚拟机是如何确定要调用哪个方法的呢？显然这里不再通过静态类型来决定了，因为静态类型同样都是 Human 的两个变量 man 和 woman 在调用 sayHello() 方法时执行了不同的行为，并且变量 man 在两次调用中执行了不同的方法。导致这个结果的原因是因为它们的实际类型不同。

#### 3.2.2 单分派与多分派

​		方法的接收者和方法的参数统称为方法的宗量，这个定义最早来源于《Java 与模式》一书。根据分派基于多少宗量，可将分派划分为**单分派**和**多分派**。

​		单分派是根据一个宗量来确定方法的执行版本；多分派则是根据多余一个宗量来确定方法的执行版本

#### 3.2.3 JVM实现动态分派

​		动态分派在 Java 中被大量使用，使用频率极其高，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率，因此 JVM 在类的方法区中建立虚方法表（virtual method table）来提高性能。每个类中都有一个虚方法表，表中存放着各个方法的实际入口。如果某个方法在子类中没有被重写，那子类的虚方法表中该方法的地址入口和父类该方法的地址入口一样，即子类的方法入口指向父类的方法入口。如果子类重写父类的方法，那么子类的虚方法表中该方法的实际入口将会被替换为指向子类实现版本的入口地址。 
​		虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。

## 四、方法的执行

### 4.1 解释执行

![](../img/JVM/编译原理.jpg)

### 4.2 基于栈的指令集与基于寄存器的指令集

​		Java 编译器输出的指令流，基本上是一种基于栈的指令集架构。指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免的要受到硬件约束。栈架构的指令集还有一些其他优点，比如相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编译实现更加简单（不需要考虑空间分配的问题，所有空间都是在栈上操作）等。

### 4.3 基于栈的代码执行示例