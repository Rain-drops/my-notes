## 一、 JVM 运行时数据区

​		Java 内存区域和内存模型是不一样的东西，内存区域是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。而内存模型（Java Memory Model，简称 JMM ）是定义了线程和主内存之间的抽象关系，即 JMM 定义了 JVM 在计算机内存(RAM)中的工作方式。

### 	1. 程序计数器--线程私有的

1. 是一块很小的内存空间。
2. 记录的是虚拟机字节码指令的地址（当前指令的地址）；如果是 Native 方法，则值为空(Undefined)。
3. 为了线程切换可以恢复到正确的执行位置（一个处理器在一个确定时刻只会执行一个线程，一个线程中包含多条指令）。
4. 生命周期随着线程的创建而创建，随着线程的结束而死亡。

> ​		由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
>
> ​		此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 	2. 虚拟机栈--线程私有

1. 每个 **Java 方法**在执行时会创建一个栈帧，存储局部变量，操作数，动态链接，方法返回地址等。
2. 每个 **Java 方法**从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。
3. 栈帧大小（局部变量）所需内存在编译期间完成分配，方法运行期间不会改变其大小。
4. 如果线程请求的栈深度大于虚拟机允许的深度，则 StackOverflowError。
5. 如果虚拟机栈可以动态扩展，扩展到无法申请足够的内存，则 OutOfMemoryError。

#### 2.1 局部变量表

​		局部变量表是存放方法参数和局部变量的区域。 局部变量没有准备阶段， 必须显式初始化。如果是非静态方法，**则在 index[0] 位置上存储的是方法所属对象的实例引用**，一个引用变量占 4 个字节，随后存储的是参数和局部变量。字节码指令中的 STORE 指令就是将操作栈中计算完成的局部变呈写回局部变量表的存储空间内。

​		虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。

#### 2.2 操作数栈

​		操作栈是个初始状态为空的桶式结构栈。在方法执行过程中，会有各种指令往栈中写入和提取信息。JVM 的执行引擎是基于栈的执行引擎，其中的栈指的就是操作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的 stack 属性中。

> **i++ 和 ++i 的区别：**
>
> 1. i++：从局部变量表取出 i 并压入操作栈(load memory)，然后对局部变量表中的 i 自增 1(add&store memory)，将操作栈栈顶值取出使用，如此线程从操作栈读到的是自增之前的值。
> 2. ++i：先对局部变量表的 i 自增 1(load memory&add&store memory)，然后取出并压入操作栈(load memory)，再将操作栈栈顶值取出使用，线程从操作栈读到的是自增之后的值。
>
> 之所以说 i++ 不是原子操作，即使使用 volatile 修饰也不是线程安全，就是因为，可能 i 被从局部变量表（内存）取出，压入操作栈（寄存器），操作栈中自增，使用栈顶值更新局部变量表（寄存器更新写入内存），其中分为 3 步，volatile 保证可见性，保证每次从局部变量表读取的都是最新的值，但可能这 3 步可能被另一个线程的 3 步打断，产生数据互相覆盖问题，从而导致 i 的值比预期的小。

#### 2.3 动态链接

​		每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。

#### 2.4 方法返回地址

方法执行时有两种退出情况：

1. 正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN 等；
2. 异常退出。

无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：

1. 返回值压入上层调用栈帧。
2. 异常信息抛给能够处理的栈帧。
3. PC计数器指向方法调用后的下一条指令。

### 	3. 本地方法栈--线程私有

1. 主要为虚拟机使用到的 Native 方法服务（一个 Native Method 就是一个 java 调用非 java 代码的接口）。

> ​		线程开始调用本地方法时，会进入一个不再受 JVM 约束的世界。本地方法可以通过 JNI（Java Native Interface）来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和 JVM 相同的能力和权限。 当大量本地方法出现时，势必会削弱 JVM 对系统的控制力，因为它的出错信息都比较黑盒。对内存不足的情况，本地方法栈还是会抛出 nativeheapOutOfMemory。
>
> ​		JNI 类本地方法最著名的应该是 `System.currentTimeMillis()` ，JNI 是 Java 深度使用操作系统的特性功能，复用非 Java 代码。 但是在项目过程中， 如果大量使用其他语言来实现 JNI , 就会丧失跨平台特性。

### 	[4. 方法区--线程共享](https://www.cnblogs.com/williamjie/p/9558094.html)

1. 被所有方法线程共享的一块运行时内存区域。是堆的逻辑组成部分。
2. 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。它用于存储每一个类的结构信息。例如，运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。

> 1. 首先，方法区是 JVM 规范的一个概念定义，并不是一个具体的实现，每一个 JVM 的实现都可以有各自的实现；
> 2. 然后，在 Java 官方的 HotSpot 虚拟机中，Java8 版本以后，是用元空间来实现的方法区；在 Java8 之前的版本，则是用永久代实现的方法区；
> 3. 也就是说，“元空间” 和 “方法区”，一个是 HotSpot 的具体实现技术，一个是 JVM 规范的抽象定义；
>
> 所以，并不能说“ JVM 的元空间是方法区”，但是可以说在 Java8 以后的 HotSpot 中“元空间用来实现了方法区”。
>
> 然后，这个元空间是使用本地内存（Native Memory）实现的，也就是说它的内存是不在虚拟机内的，所以可以理论上物理机器还有多个内存就可以分配，而不用再受限于 JVM 本身分配的内存了。

#### 4.1 JDK8以后的元数据区

​		JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。

> JDK7 开始了方法区的部分移除：**符号引用（Symbols）**移至 **native heap**，**字面量（interned strings）**和**静态变量（class statics）**移至 **java heap**。

##### 4.1.1 metaspace 的组成

首先插入一小段题外话，**class文件的加载**。JVM 规范中定义了 class 文件加载的至少三个步骤：

- 通过一个类的全限定名获得这个类的二进制字节流
- 将这个字节流代表的静态存储结构转化为**运行时数据结构（klass）**
- 在内存中生成一个代表这个类的 **java.lang.Class 对象**, 作为方法区这个类的各个数据的访问入口

在 JDK1.6 以前运行时数据结构和 Class 对象都是存放在永久代中的，但是 JDK1.8 之后，Class对象存放到了 heap 中，klass 数据和其他和该类相关的数据存放在元数据区。

元数据区分为两个部分:

> ​	1. klass Metaspace：非必须，紧接着 heap 的连续空间，目的是提高性能，当不开启压缩指针开关时或 -Xmx 大于 32G（自动关闭压缩指针）时, 这个空间都不存在，klass 数据也放到 no-klass 中。
>
>   		2. no-klass Metaspace：必须，在 native memory 中的非连续空间，存放 klass 以外的其他数据（比如 method、constantPool 等）, 也可以存放 klass
>

总结一下 metaspace 的特点和好处:

> 1. 位置移到了堆外使用native memory, 取消了原来的大小限制, 采用新的参数进行控制
> 2. 字符串常量和Class对象移到了heap中管理
> 3. 类和类加载器的生命周期一致, 不需要单独回收某个类的空间, 当类加载器被回收时, 所属metaspace的内存一并回收

#### 4.2 运行时常量池

​		Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

​		一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

​		运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。



### 	5. 堆--线程共享

1. 堆是 java 虚拟机管理内存最大的一块内存区域
2. 用于存放对象实例和数组

> Java 堆中可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等。从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。

### 7. 直接内存

​		直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。

​		在 JDK 1.4 中新加入了 NIO，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

![](D:/Book/MyNotes/my-notes/img/jvm/运行时数据区表格.png)

## 二、Java 内存模型（JMM）

​		Java 内存模型是共享内存的并发模型，线程之间主要通过读-写共享变量（堆内存中的实例域，静态域和数组元素）来完成隐式通信。

​		Java 内存模型（JMM）控制 Java 线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见。

### 1. 计算机高速缓存和缓存一致性

​		计算机在高速的 CPU 和相对低速的存储设备之间使用高速缓存，作为内存和处理器之间的缓冲。将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中。

​		在多处理器的系统中(或者单处理器多核的系统)，每个处理器内核都有自己的高速缓存，它们有共享同一主内存(Main Memory)。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。为此，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，来维护缓存的一致性。

![](../img/jvm/JMM_CPU.png)

### 2. JVM主内存与工作内存

​		Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量（线程共享的变量）存储到内存和从内存中取出变量这样底层细节。Java 内存模型中规定了所有的变量都存储在主内存中，每条线程有自己的工作内存，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。这里的工作内存是 JMM 的一个抽象概念，也叫本地内存，其存储了该线程以读 / 写共享变量的副本。

​		不同线程之间无法直接访问对方工作内存中的变量，线程间的通信一般有两种方式进行，一是通过消息传递，二是共享内存。Java 线程间的通信采用的是共享内存方式。

### 3. 重排序和happens-before规则

#### 3.1 指令重排序

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。

> 重排序分三种类型：
>
> 1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
> 2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
> 3. 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

#### 3.2 内存屏障

​		JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

​		java 编译器禁止处理器重排序是通过在生成指令序列的适当位置会插入内存屏障（重排序时不能把后面的指令重排序到内存屏障之前的位置）指令来实现的。

#### 3.3 happens-before

​		如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。

​		如果 A happens-before B，那么 Java 内存模型将向程序员保证—— A 操作的结果将对 B 可见，且 A 的执行顺序排在 B 之前。

> 重要的 happens-before 规则如下：
>
> 1. 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
> 2. 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。
> 3. volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。
> 4. 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。

### 4. volatile关键字

​		volatile 可以说是 JVM 提供的最轻量级的同步机制。

> 当一个变量定义为volatile之后，它将具备两种特性：
>
> 1. **保证此变量对所有线程的可见性。**而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。
>
>    注意，volatile 虽然保证了可见性，但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。而 synchronized 关键字则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得线程安全的。
>
> 2. **禁止指令重排序优化。**普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。