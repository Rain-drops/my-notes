### 一、简述

每个线程操作数据时会把数据从主内存读取到自己的工作内存，操作完成后把数据从新写入主内存，这时其他已经读取的线程中的变量副本就会失效，需要对数据进行操作就又要去主存中读取。

#### 1. 缓存一致性

1. 缓存一致性协议

   > **MSI：**
   >
   > **MESI：**当 CPU 写数据时，如果发现操作的变量是共享变量，会发出信号通知其他 CPU 将该变量设置为无效状态，因此当其他 CPU 读取这个变量时，发现自己缓存中该变量的缓存是无效的状态，就会从内存中重新读取。
   >
   > **MOSI：**
   >
   > **Synapse：**
   >
   > **Firefly：**
   >
   > **DragonProtocol：**

2. 嗅探

   > 每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态。

3. 总线风暴

   > 缓存一致性需要不断的从主内存嗅探和 CAS，无效的交互会导致总线的带宽达到峰值。

#### 2. 禁止指令重排序

1. 什么是重排序

   > 为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。
   >
   > 不管怎么重排序，单线程下的执行结果不能被改变。

2. 重排序的类型

   > 编译器优化重排序：
   >
   > 指令级并行重排序：
   >
   > 内存系统重排序：

3. 内存屏障

   一种 **CPU 屏障指令**，它使 CPU 或编译器对屏障指令之前和之后发出的**内存操作**执行一个**排序约束**

   > java 的内存屏障通常所谓的四种即 LoadLoad，StoreStore，LoadStore，StoreLoad
   >
   > - LoadLoad 屏障：对于这样的语句 `Load1; LoadLoad; Load2` ，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。
   > - StoreStore 屏障：对于这样的语句 `Store1; StoreStore; Store2` ，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。
   > - LoadStore 屏障：对于这样的语句 `Load1; LoadStore; Store2` ，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据被读取完毕。
   > - StoreLoad 屏障：对于这样的语句 `Store1; StoreLoad; Load2` ，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。**它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能**

### 二、volatile

​		volatile 是一个类型修饰符，作用是作为指令关键字，确保本条指令不会因编译器的优化而省略		

​		volatile 用于将变量标记为“存储在**主内存**中”，对于 volatile 变量的每次读操作都会直接从计算机的主内存中读取，同样对于 volatile 变量的写操作只写入主存，而不是仅仅写入 CPU 缓存。

​		对于非 volatile 变量时，每个线程都会从系统内存（主内存）拷贝变量到工作内存中，然后修改工作内存中的变量值，操控的变量可能不同。

#### 1. 内存可见性

​		volatile 是轻量级的 synchronized，他在多处理器中保证共享变量的**可见性**。

​		可见性的意思是：当一个线程修改一个共享变量时，另一个线程能读到这个修改的值。volatile 之所以比 synchronized 执行成本更低是因为他不需要切换上下文和调度。

​		当写一个 volatile 变量时，Java 内存模型（ JMM ）会把线程对应的本地内存中的共享变量刷新到**主内存**中；

​		当读一个 volatile 变量时，JMM 会把线程对应的本地内存无效化，接下来线程会从主存中读取这个 volatile 变量。

#### 2. volatile 是怎么保证不会被执行重排序的？

> **volatile 写操作：**是在前面和后面分别插入内存屏障，禁止上面写和他重排序，禁止下面读和他重排序。
>
> **volatile 读操作：**在后面插入两个内存屏障，禁止下面读重排序，禁止下面写重排序。

> 为了实现 volatile 的内存语义，JMM 会限制特定类型的编译器和处理器重排序，JMM 会针对编译器制定 volatile 重排序规则表。
>
> |  是否能重排序  | 第二个操作 |             |             |
> | :------------: | :--------: | :---------: | :---------: |
> | **第一个操作** | 普通读/写  | volatile 读 | volatile 写 |
> |   普通读/写    |            |             |     NO      |
> |  volatile 读   |     NO     |     NO      |     NO      |
> |  volatile 写   |            |     NO      |     NO      |

#### 3. volatile 是不安全的

​		虽然 volatile 可见性保证了对 volatile 变量所有的写操作都能立刻反应到其他线程之中（即 volatile 变量在各个线程中都是一致的），但是 Java 里面的运算并非原子操作。只有是原子操作的 volatile 变量才是线程安全的，比如我们很常见的 变量++ 自增操作，在这个过程中，自增包括取数，加一，保存三个过程的操作，所以自增并不是原子性操作，使用 volatile 修饰的变量自增操作仍然是不安全的。

#### 4. volatile 不适用场景

​		由于 volatile 变量只能保证可见性，在**不符合**以下两条规则的运算场景中，我们仍然要通过加锁（使用 synchronized 或 java.util.concurrent 中的原子类）来保证原子性。

- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
- 变量不需要与其他的状态变量共同参与不变约束